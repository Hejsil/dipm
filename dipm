#!/bin/sh

program_name='dipm'

cache_home=${XDG_CACHE_HOME:-$HOME/.cache}
data_home=${XDG_DATA_HOME:-$HOME/.local/share}

bin_dir="$HOME/.local/bin"
cache_dir="$cache_home/$program_name"
data_dir="$data_home/$program_name"
mkdir -p "$bin_dir" "$cache_dir" "$data_dir"

pkgs_file="$cache_dir/pkgs.ini"
installed_file="$data_dir/installed.ini"

pkgs_url='https://raw.githubusercontent.com/Hejsil/dipm-pkgs/master/pkgs.ini'

usage() {
    echo 'Usage: dipm [command] [options]'
    echo
    echo 'Commands:'
    echo '  install <name>     Install a package'
    echo '  uninstall <name>   Uninstall a package'
    echo '  update <name>      Update a package'
    echo '  update             Update all packages'
    echo '  list               List all installed packages and their versions'
    echo '  help               Print this help and exit'
}

ini_section() {
    section=$1
    awk "/^\[.*\]$/ {print_it=0} /^\[$section\]$/ {print_it=1} print_it"
}

ini_delete_section() {
    section=$1
    awk "/^\[.*\]$/ {print_it=1} /^\[$section\]$/ {print_it=0} print_it"
}

ini_field() {
    field=$1
    grep "${field}=" | cut -d'=' -f2-
}

error_if_empty() {
    string=$1
    msg=$2
    if [ -z "$string" ]; then
        echo "$msg" >&2
        return 1
    fi
}

error_if_file() {
    string=$1
    msg=$2
    if [ -f "$string" ]; then
        echo "$msg" >&2
        return 1
    fi
}

error_if_not_file() {
    string=$1
    msg=$2
    if ! [ -f "$string" ]; then
        echo "$msg" >&2
        return 1
    fi
}

download_url_to() {
    link=$1
    dir=$2

    if command -v wget >/dev/null; then
        if ! wget --show-progress -qP "$dir" "$link"; then
            echo "error: could not download '$link'" >&2
            return 1
        fi
        return
    fi
    if command -v curl >/dev/null; then
        if ! curl --progress-bar -LO --output-dir "$dir" "$link"; then
            echo "error: could not download '$link'" >&2
            return 1
        fi
        return
    fi

    echo 'error: system is missing curl or wget' >&2
    return 1
}

is_pkgs_file_up_to_date() {
    if ! [ -e "$pkgs_file" ]; then
        return 1
    fi

    date_format='+%Y-%m-%d'
    today=$(date "$date_format")
    last_modified=$(date -r "$pkgs_file" "$date_format")
    [ "$today" = "$last_modified" ]
}

download_pkgs_file() {
    tmp_dir=$(mktemp -dt 'dipm.XXXXXXXX')
    if download_url_to "$pkgs_url" "$tmp_dir"; then
        mv "$tmp_dir/pkgs.ini" "$pkgs_file"
    fi

    rm -r "$tmp_dir"
}

download_pkgs_file_if_out_of_date() {
    if ! is_pkgs_file_up_to_date; then
        download_pkgs_file
    fi
}

validate_pkg_hash() {
    expected_hash=$1
    download_dir=$2

    actual_hash=$(find "$download_dir" -type f -exec sha256sum '{}' ';' | cut -d' ' -f1)

    if [ "$expected_hash" != "$actual_hash" ]; then
        echo 'error: hash mismatch' >&2
        echo "  expected $expected_hash" >&2
        echo "  found    $actual_hash" >&2
        return 1
    fi
}

extract_pkg() {
    download_dir=$1

    file=$(find "$download_dir" -type f)
    file_mime=$(file -b --mime-type "$file")
    case $file_mime in
        application/gzip) tar -xvf "$file" -C "$download_dir" >/dev/null ;;
        application/x-bzip2) tar -xvf "$file" -C "$download_dir" >/dev/null ;;
        application/x-xz) tar -xvf "$file" -C "$download_dir" >/dev/null ;;
        application/zip) {
            cd "$download_dir" || return 1
            unzip "$file" >/dev/null
        } ;;
        *) ;;
    esac
}

install_pkg() {
    pkg=$1
    install_bin=$2
    version=$3
    download_dir=$4

    echo "[$pkg]" >>"$installed_file"
    echo "version=$version" >>"$installed_file"
    echo "$install_bin" | tr ':' '\t' | while read -r name from; do
        if [ -z "$from" ]; then
            from="$name"
            name=''
        fi
        install_pkg_file 'bin' "$download_dir" "$from" "$name" || return 1
    done
}

install_pkg_file() {
    type=$1
    from_dir=$2
    from=$3
    name=${4:-$(basename "$from")}

    case $type in
        bin) install_dir=$bin_dir ;;
    esac

    from_location="$from_dir/$from"
    install_location="$install_dir/$name"

    error_if_not_file "$from_location" "error: file '$from' doesn't exist" || return 1
    error_if_file "$install_location" "error: file '$install_location' already exists" || return 1

    cp -r "$from_location" "$install_location"
    case $type in
        bin) chmod +x "$install_location" ;;
    esac

    echo "location=$install_location" >>"$installed_file"
}

is_pkg_installed() {
    pkg=$1
    if ! [ -f "$installed_file" ]; then
        return 1
    fi

    section=$(ini_section "$pkg" <"$installed_file")
    version=$(echo "$section" | ini_field "version")
    location=$(echo "$section" | ini_field "location")

    [ -n "$version" ] && [ -n "$location" ]
}

install_using_dir() {
    pkg=$1
    dir=$2

    if is_pkg_installed "$pkg"; then
        echo "$pkg is already installed" >&2
        return 1
    fi

    os=$(uname -s | tr '[:upper:]' '[:lower:]')
    arch=$(uname -m)

    info_section=$(ini_section "$pkg\.info" <"$pkgs_file")
    arch_section=$(ini_section "$pkg\.${os}_${arch}" <"$pkgs_file")
    version=$(echo "$info_section" | ini_field 'version')
    install_bin=$(echo "$arch_section" | ini_field 'install_bin')
    url=$(echo "$arch_section" | ini_field 'url')
    expected_hash=$(echo "$arch_section" | ini_field 'hash')

    error_if_empty "$version" "error: '$pkg' does not have field 'version'" || return 1
    error_if_empty "$install_bin" "error: '$pkg' does not have field 'install_bin'" || return 1
    error_if_empty "$url" "error: '$pkg' does not have field 'url'" || return 1
    error_if_empty "$expected_hash" "error: '$pkg' does not have field 'hash'" || return 1

    download_url_to "$url" "$dir" || return 1
    if [ "$DIPM_DEBUG" ]; then
        echo "debug: after download:" >&2
        tree -h "$dir" >&2
    fi

    validate_pkg_hash "$expected_hash" "$dir" || return 1
    extract_pkg "$dir" || return 1
    if [ "$DIPM_DEBUG" ]; then
        echo "debug: after extraction:" >&2
        tree -h "$dir" >&2
    fi

    install_pkg "$pkg" "$install_bin" "$version" "$dir" || {
        uninstall "$pkg" >/dev/null 2>/dev/null
        return 1
    }
}

install() {
    pkg=$1
    tmp_dir=$(mktemp -dt 'dipm.XXXXXXXX')

    install_using_dir "$1" "$tmp_dir"
    exit_code=$?

    rm -r "$tmp_dir"

    return "$exit_code"
}

list() {
    pkgs=$(mktemp -t 'dipm.XXXXXXXX')
    versions=$(mktemp -t 'dipm.XXXXXXXX')

    grep '^\[.*\]$' "$installed_file" | tr -d '][' >"$pkgs"
    grep '^version=' "$installed_file" | sed 's/version=//' >"$versions"
    paste "$pkgs" "$versions"

    rm "$pkgs" "$versions"
}

uninstall() {
    pkg=$1
    section=$(ini_section "$pkg" <"$installed_file")
    location=$(echo "$section" | ini_field "location")

    new_installed_file=$(mktemp -t 'dipm.XXXXXXXX')
    ini_delete_section "$pkg" <"$installed_file" >"$new_installed_file"
    mv "$new_installed_file" "$installed_file"

    error_if_empty "$location" "error: '$pkg' is not installed" || return 1
    echo "$location" | xargs -d'\n' rm -r
}

update_no_check() {
    pkg=$1
    uninstall "$pkg" || return 1
    install "$pkg" || return 1
}

update_all() {
    list | while read -r pkg old_version; do
        info_section=$(ini_section "$pkg\.info" <"$pkgs_file")
        new_version=$(echo "$info_section" | ini_field 'version')
        if [ "$old_version" = "$new_version" ]; then
            continue
        fi

        update_no_check "$pkg"
    done
}

update() {
    pkg=$1
    if [ -z "$pkg" ]; then
        update_all
        return
    fi

    if ! is_pkg_installed "$pkg"; then
        echo "$pkg is not installed" >&2
        return 1
    fi

    installed_section=$(ini_section "$pkg" <"$installed_file")
    info_section=$(ini_section "$pkg\.info" <"$pkgs_file")

    old_version=$(echo "$installed_section" | ini_field 'version')
    new_version=$(echo "$info_section" | ini_field 'version')
    if [ "$old_version" = "$new_version" ]; then
        echo "$pkg is up to date" >&2
        return 1
    fi

    update_no_check "$pkg"
}

cmd=$1
pkg=$2

case $cmd in
    install)
        download_pkgs_file_if_out_of_date
        install "$pkg"
        ;;
    update)
        download_pkgs_file_if_out_of_date
        update "$pkg"
        ;;
    list) list ;;
    uninstall) uninstall "$pkg" ;;
    -h | --help | help) usage ;;
    *)
        echo "error: Unknown command '$cmd'"
        usage >&2
        ;;
esac
